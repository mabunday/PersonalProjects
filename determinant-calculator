# 06/27/2019
import numpy as np

# INPUT MATRIX DIMENSIONS
print("matrix m x n. input dimensions:")

# checking for n x n dimensions
# dim_'x' = dimension in type 'x'
dim_str = input("")
dim_list = dim_str.split(" ")

while dim_list[0] != dim_list[2]:
    print("Invalid matrix. Accept only matrices of n x n.")
    dim_str = input("")
    dim_list = dim_str.split(" ")
else:
    pass

dim = int(dim_list[0])


# INPUT MATRIX VALUES
# mat_row = list of one row in matrix
# mat_val = list of 'mat_row'

def row_input():
    row_number = 1
    print("""
input matrix row by row
separate terms by commas
press enter after each row """)
    mat_vals = ""
    for a in range(dim):
        mat_row = input(f"row {row_number}: ")
        compatible = False
        while not compatible:
            try:
                test = [float(num) for num in mat_row.split(",")]

                # checking for dimension fit
                if len(test) != dim:
                    print("M Format is not compatible. Reenter row.")
                    mat_row = input(f"row {row_number}: ")
                else:
                    row_number += 1
                    mat_vals += mat_row
                    compatible = True

                # applies only after first input
                if row_number != 1:
                    mat_vals += ','
                else:
                    pass

            # checking for format fit
            except ValueError:
                print("Format is not compatible. Reenter row.")
                mat_row = input(f"row {row_number}: ")
    return mat_vals


# CONVERTING SEPARATED ROW INPUTS TO ONE MATRIX
# num_'x' = entered numbers in type 'x'
num_str = row_input()
num_list = [float(num) for num in num_str.split(",")]
num_mat = [num_list[i * dim:(i + 1) * dim] for i in range((dim ** 2 + dim - 1) // dim)]
A = matrix_A = np.array(num_mat)
print(A)


# ROW REDUCING (rrf) TO A DIAGONAL MATRIX
# a = row being reduced to zero
# b = row remaining in the diagonal
# c and d scale rows a and b to the same number
def diag_mat(matrix):
    for b in range(len(matrix)):
        for a in range(len(matrix[0])):
            if a <= b:
                pass
            else:
                # avoiding ZeroDivisionError
                if matrix[b][b] == 0:
                    pass
                else:
                    matrix[a] = matrix[a] - matrix[b] * (matrix[a][b] / matrix[b][b])

    print(f"""
diagonal matrix:
{matrix}""")


diag_mat(A)


# FINDING THE DETERMINANT BY MULTIPLYING DIAGONAL
# l = number of values in the diagonal
# m = diagonal position (A[m][m] = diagonal value)
# n = multiplied diagonal values complied: determinant
def multiply_diag(matrix):
    n = matrix[0][0]
    for l in range(len(matrix)-1):
        m = l + 1
        n *= float(A[m][m])
    # undoing negative zero answers
    if n == -0:
        n = abs(n)
    print("")
    print(f"determinant of matrix: {n}")
    return n


# LINEAR INDEPENDENCE
determinant = multiply_diag(A)
if determinant == 0:
    print("Matrix is linearly dependent.")
else:
    print("Matrix is linearly independent.")
